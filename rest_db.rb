#!/usr/bin/ruby1.8 -w
#Version 1.3
#A rest client DB interface. Implements add, del, and get for attributes.
#Adapting to the new "interface" defined at http://www.orbit-lab.org/wiki/Software/bAM/aInventory 

require 'log_wrap'
require 'rest_client'

class DelAttrError < StandardError
end

class AddAttrError < StandardError
end

class GetAttrError < StandardError
end

class BadAttrName < StandardError
end

class AddResError < StandardError
end

class DelResError < StandardError
end

class Tools
	#Class of Tools  for manipulating the arrays from the DB
	@@log = LOG.instance

	def self.tuple?(c)
		#the definintion of a tuple, 
	       	return(c.class == Array and c.length == 2 and c.count{|d| d.class == Array} == 0)
	end

	def self.contains?(w,c)
		#does this nestest structure contain the word w
		return !c.join(" ").match(Regexp.escape(w)).nil?
	end

	def self.tuples(current)
		#an Example of a proper recursive call (instead of using a side effect). 
		test_cond = lambda {|n| 
			if Tools.tuple?(n)
			       #return if it was a tuple	
			#	puts "Debug message: Was a tuple #{n.join(" ")}"
				return  [n]
			else
				#if it is not a tuple, check if it is an array
			       if n.class == Array
				       #if it is, call the recursive step, note the flatten(1) at the end. This will collpase one level of nesting which is generated by the call to map 
			#	       puts "Debug Message: Was not a tuple #{n}"
				       val = n.map{|x| test_cond.call(x)}.flatten(1)
				       @@log.debug("Tools.tuples: Result of recursive call #{val}")
				       return val
			       else
				       #other wise return a nil (these will be compacted out)
				       @@log.debug("Tools.tuples: Not either #{n}")
				       return nil
			       end
			end
		}
		#the resursive call onto the given data. Since we need to do at least one map we wrap current into an array. We'll remove that mapping by using a flatten(1).
		return [current].map{|y| test_cond.call(y)}.flatten(1).compact
	end

	def self.dig(word, current)
		#recursivley digs nested arrays for string word and find the containers of word should only dig into things can contain a unquie copy of word
		store = Array.new
		#Store if it is a tuple and contains w, other wise recurse  on all sub arrays
		calc = lambda {|w,s,c| self.tuple?(c) ? (s.push(c) if self.contains?(w,c)) : (c.each{|f| calc.call(w,s,f)} if c.class == Array)}
		calc.call(word,store,current)
		return store
	end

	def self.get_last(array)
		return array.flatten.last
	end
end

class Database
	#Container for the live object rest api
	def initialize(host, prefix)
		@log = LOG.instance

		#the prefix value is what the del_all_attr method uses to filter records. It must be set, and any attributes submitted to the add method will be checked for this prefix.
		@prefix = prefix

		#By default this should be "http://internal1.orbit-lab.org:5054/inventory/"
		@host = host
		begin
			connect = RestClient.get @host
			@log.info("Restfull DB connected to #{@host}")
			@log.debug("with code: #{connect.code} \ncookies: #{connect.cookies} \nheaders: #{connect.headers}")
		rescue
			@log.warn("Cant connect to host")
			raise
		end

	end

	def del_attr(resource,name)
		#delete attributes from resources
		#resource is the resource FQDN, and name is the attribute name
		#This will delete an attribute reguardless of prefix (Use with caution)
		
		host  = @host + "attribute_delete"
		begin
			result = RestClient.get host, {:params => {:name => resource, :attribute => name}}
			@log.debug("Resource #{resource} had #{name} deleted  with result  #{result.to_str}")
			raise DelAttrError , result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue DelAttrError
			@log.debug("Attribute Deleteion failed with error \n #{result.to_str}")
			raise
		rescue 
			@log.fatal("Attribute Deleteion failed}")
			raise
		end
		return result
	end

	def del_all_attr(resource)
		#delete attributes from resources that are prefixed with @prefix
		#resource, name resource FQDN, and attribute name respectively. 
		host  = @host + "attribute_delete"
		begin
			result = RestClient.get host, {:params => {:name => resource, :attribute => "#{@prefix}*"}}
			@log.debug("Resource #{resource} had attributes deleted  with result  #{result.to_str}")
			raise DelAttrError , result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue DelAttrError
			@log.debug("Attribute Deleteion failed with error \n #{result.to_str}")
			raise
		rescue 
			@log.fatal("Attribute Deleteion failed}")
			raise
		end
		return result
	end

	def modify_attr(resource,name,value)
		#modify an attribute to a resource
		#resource, name and value are strings are the resource FQDN, attribute name, and attrbute value respectively. 
		#Name must be prefixed with @prefix other wise it's going to complain
		host  = @host + "attribute_modify"

		#I won't adjust your name, but I will bark at you if you don't comply
		raise BadAttrName, "Must prefix attribute name with #{@prefix}" if name.match(/^#{@prefix}/).nil?

		begin
			result = RestClient.get host, {:params => {:name => resource, :attribute => name, :value => value}}
			@log.debug("Resource #{resource} had #{name}=#{value} set  with result  #{result.to_str}")
			raise AddAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddAttrError
			@log.warn("Attribute modify failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute modify failed")
			raise
		end
		return result
	end

	def add_attr(resource,name,value)
		#adds an attribute to a resource
		#resource, name and value are strings are the resource FQDN, attribute name, and attrbute value respectively. 
		#Name must be prefixed with @prefix other wise it's going to complain
		host  = @host + "attribute_add"

		#I won't adjust your name, but I will bark at you if you don't comply
		raise BadAttrName, "Must prefix attribute name with #{@prefix}" if name.match(/^#{@prefix}/).nil?

		begin
			result = RestClient.get host, {:params => {:name => resource, :attribute => name, :value => value}}
			@log.debug("Resource #{resource} had #{name}=#{value} set  with result  #{result.to_str}")
			raise AddAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddAttrError
			@log.warn("Attribute addition failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute addition failed")
			raise
		end
		return result
	end

	def get_attr(resource)
		#gets the attribues of a given resource from the data base
		#resource is a string, the FQDN of the resource we want data for
		host  = @host + "attribute_list"
		begin
			result = RestClient.get host, {:params => {:set => resource, :attribute => "*"}}
			raise GetAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
			#parse string for key=value pairs
			return result.to_str.scan(/(\S*)='(.*?)'/)
		rescue GetAttrError
			@log.warn("Get attribute failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute retrival failed")
			raise
		end
	end

	def del_resource(resource)
		#resource is a string,  the name (or partial_name) of the resouce being added
		host  = @host + "resource_delete"

		begin
			result = RestClient.get host, {:params => {:set => resource}}
			@log.debug("Resource #{resource} had delete  with result  #{result.to_str}")
			raise AddResError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddResError
			@log.warn("Resource deletion failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Resource deleteion failed")
			raise
		end
		return result
	end

	def add_resource(resource,type)
		#adds a resource
		#resource is name of the resource (usually  fqdn of node + some moniker) and type (usually device)
		host  = @host + "resource_add"

		begin
			result = RestClient.get host, {:params => {:name => resource, :type => type}}
			@log.debug("Resource #{resource} had type=#{type} set  with result  #{result.to_str}")
			raise AddResError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddResError
			@log.warn("Resource addition failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Resource addition failed")
			raise
		end
		return result
	end

	def add_relation(parent,child)
		#adds an attribute to a resource
		#parent is fqdn of node and child is usually parent fqdn + moniker
		#Name must be prefixed with @prefix other wise it's going to complain
		host  = @host + "relation_add"

		begin
			result = RestClient.get host, {:params => {:parent => parent, :child => child}}
			@log.debug("#{parent} to #{child} relation added with  #{result.to_str}")
			raise AddResError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddResError
			@log.warn("Relation addition failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Relation addition failed")
			raise
		end
		return result
	end

	def list_relation(parent)
		#parent is a string, name of the parent to check wheter children exist. Returns an array of strings which are the resource names of the children.
		host  = @host + "resource_list"

		begin
			result = RestClient.get host, {:params => {:parent => parent}}
			children = result.to_str.scan(/resource name='(.*?)'/).flatten
			@log.debug("#{parent} has #{children.length} relations  #{result.to_str}")
			raise AddResError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddResError
			@log.warn("Relation addition failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Relation addition failed")
			raise
		end
		return children
	end
end
