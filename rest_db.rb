#!/usr/bin/ruby1.8 -w
#Version 1.2
#A rest client DB interface. Implements add, del, and get for attributes.
# This version imposes the prefix requirement. prefix value is set when db object is instantiated.

require 'log_wrap'
require 'rest_client'

class DelAttrError < StandardError
end

class AddAttrError < StandardError
end

class GetAttrError < StandardError
end

class BadAttrName < StandardError
end


class Tools
	#Class of Tools  for manipulating the arrays from the DB
	def self.tuple?(c)
		#the definintion of a tuple, 
	       	return(c.class == Array and c.length == 2 and c.count{|d| d.class == Array} == 0)
	end

	def self.contains?(w,c)
		#does this nestest structure contain the word w
		return !c.join(" ").match(Regexp.escape(w)).nil?
	end

	def self.tuples(current)
		#pulls out nested tuples 
		#TODO the ternary operation should be tuple? ?  return tuple : return insides
		store = Array.new
		#store if it is a tuple other wise call on each element that is an array
		calc = lambda {|s,c| self.tuple?(c) ? s.push(c) : (c.each{|f| calc.call(s,f)} if c.class == Array)}
		calc.call(store,current)
		return store
	end

	def self.tuples_alt(current)
		#an Example of a proper recursive call (instead of using a side effect). 
		test_cond = lambda {|n| 
			if Tools.tuple?(n)
			       #return if it was a tuple	
			#	puts "Debug message: Was a tuple #{n.join(" ")}"
				return  [n]
			else
				#if it is not a tuple, check if it is an array
			       if n.class == Array
				       #if it is, call the recursive step, note the flatten(1) at the end. This will collpase one level of nesting which is generated by the call to map 
			#	       puts "Debug Message: Was not a tuple #{n}"
				       val = n.map{|x| test_cond.call(x)}.flatten(1)
				       puts "Debug Message: Result of recursive call #{val}"
				       return val
			       else
				       #other wise return a nil (these will be compacted out)
				       puts "Debug Message: Not either #{n}"
				       return nil
			       end
			end
		}
		#the resursive call onto the given data. Since we need to do at least one map we wrap current into an array. We'll remove that mapping by using a flatten(1).
		return [current].map{|y| test_cond.call(y)}.flatten(1).compact
	end

	def self.dig(word, current)
		#recursivley digs nested arrays for string word and find the containers of word should only dig into things can contain a unquie copy of word
		store = Array.new
		#Store if it is a tuple and contains w, other wise recurse  on all sub arrays
		calc = lambda {|w,s,c| self.tuple?(c) ? (s.push(c) if self.contains?(w,c)) : (c.each{|f| calc.call(w,s,f)} if c.class == Array)}
		calc.call(word,store,current)
		return store.flatten
	end

	def self.dig_regexp(reg, current)
		#TODO this is wrong.
		#recursivley digs nested arrays for regexp and find the containers of word should only dig into things can contain a unquie copy of word
		store = Array.new
		#Store if it is a tuple and contains w, other wise recurse  on all sub arrays
		calc = lambda {|r,s,c| self.tuple?(c) ? (s.push(c) if c.join(" ").match(r)) : (c.each{|f| calc.call(r,s,f)} if c.class == Array)}
		calc.call(reg,store,current)
		return store.flatten
	end
end

class Database
	#Container for the live object rest api
	def initialize(host, prefix)
		@log = LOG.instance

		#the prefix value is what the del_all_attr method uses to filter records. It must be set, and any attributes submitted to the add method will be checked for this prefix.
		@prefix = prefix

		#By default this should be "http://internal1.orbit-lab.org:5054/inventory/"
		@host = host
		begin
			connect = RestClient.get @host
			@log.info("Restfull DB connected to #{@host}")
			@log.debug("with code: #{connect.code} \ncookies: #{connect.cookies} \nheaders: #{connect.headers}")
		rescue
			@log.fatal("Cant connect to host")
			raise
		end

	end

	def del_attr(node,name)
		#delete attributes from nodes
		#node, name node FQDN, and attribute name respectively. 
		#This will delete an attribute reguardless of prefix (Use with caution)
		
		host  = @host + "attribute/delete"
		begin
			result = RestClient.get host, {:params => {:rn => node, :attribute => name}}
			@log.debug("Node #{node} had #{name} deleted  with result  #{result.to_str}")
			raise DelAttrError , result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue DelAttrError
			@log.debug("Attribute Deleteion failed with error \n #{result.to_str}")
			raise
		rescue 
			@log.fatal("Attribute Deleteion failed}")
			raise
		end
		return result
	end

	def del_all_attr(node)
		#delete attributes from nodes that are prefixed with @prefix
		#node, name node FQDN, and attribute name respectively. 
		host  = @host + "attribute/delete"
		begin
			result = RestClient.get host, {:params => {:rn => node, :attribute => "#{@prefix}*"}}
			@log.debug("Node #{node} had attributes deleted  with result  #{result.to_str}")
			raise DelAttrError , result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue DelAttrError
			@log.debug("Attribute Deleteion failed with error \n #{result.to_str}")
			raise
		rescue 
			@log.fatal("Attribute Deleteion failed}")
			raise
		end
		return result
	end

	def add_attr(node,name,value)
		#adds an attribute to a node
		#node, name and value are strings, node FQDN, attribute name, and value respectively. 
		#Name must be prefixed with @prefix other wise it's going to complain
		host  = @host + "attribute/add"

		#I won't adjust your name, but I will bark at you if you don't comply
		raise BadAttrName, "Must prefix attribute name with #{@prefix}" if name.match(/^#{@prefix}/).nil?

		begin
			result = RestClient.get host, {:params => {:rn => node, :attribute => name, :value => value}}
			@log.debug("Node #{node} had #{name}=#{value} set  with result  #{result.to_str}")
			raise AddAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
		rescue AddAttrError
			@log.warn("Attribute addition failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute addition failed")
			raise
		end
		return result
	end

	def get_attr(node)
		#gets the attribues of a given node from the data base
		#node is a string, the FQDN of the node we want data for
		host  = @host + "attribute/list"
		begin
			result = RestClient.get host, {:params => {:rn => node}}
			raise GetAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
			#parse string for key=value pairs
			return result.to_str.scan(/(\S*)='(.*?)'/)
		rescue GetAttrError
			@log.warn("Get attribute failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute retrival failed")
			raise
		end
	end

	def get_all_node(fqdn)
		#Gets the all the attributes for a given fqdn e.g. "grid.orbit-lab.org"
		host  = @host + "attribute/list" 
		begin
			result = RestClient.get host, {:params => {:rn => "*." + fqdn}}
			raise GetAttrError, result.to_str unless result.to_str.scan(/ERROR/).empty?
			#pull out individual node strings
			nodes = result.scan(/<node(.*?)\/>/)
			#parse each string for key=value pairs
			return nodes.map{|arr| arr.first.scan(/(\S*)='(.*?)'/)}
		rescue GetAttrError
			@log.warn("Get attribute failed with error \n #{result.to_str}")
			raise
		rescue
			@log.fatal("Attribute retrival failed")
			raise
		end
	end

end
